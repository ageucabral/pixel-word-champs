import { supabase } from '@/integrations/supabase/client';
import { ApiResponse } from '@/types';
import { createSuccessResponse, createErrorResponse, handleServiceError } from '@/utils/apiHelpers';

interface CompetitionFormData {
  title: string;
  description: string;
  competition_type: string;
  start_date: string;
  end_date: string;
  max_participants: number;
  prize_pool: number;
  theme?: string;
  rules?: any;
  status?: string;
}

export interface CustomCompetitionData {
  title: string;
  description: string;
  type: 'daily' | 'weekly';
  category?: string;
  weeklyTournamentId?: string;
  prizePool: number;
  maxParticipants: number;
  startDate?: string; // STRING PURA - sem convers√µes
  endDate?: string;   // STRING PURA - sem convers√µes
}

export class CustomCompetitionCoreService {
  /**
   * Verifica se h√° sobreposi√ß√£o de datas APENAS entre competi√ß√µes semanais
   * Competi√ß√µes di√°rias podem coexistir em qualquer data
   */
  private async checkWeeklyCompetitionOverlap(startDate: string, endDate: string): Promise<boolean> {
    try {
      console.log('üîç Verificando sobreposi√ß√£o APENAS entre competi√ß√µes semanais (STRINGS PURAS):', { startDate, endDate });
      
      const { data: existingWeeklyCompetitions, error } = await supabase
        .from('custom_competitions')
        .select('id, title, start_date, end_date')
        .eq('competition_type', 'tournament') // APENAS competi√ß√µes semanais
        .neq('status', 'completed');

      if (error) {
        console.error('‚ùå Erro ao buscar competi√ß√µes semanais existentes:', error);
        throw error;
      }

      if (!existingWeeklyCompetitions || existingWeeklyCompetitions.length === 0) {
        console.log('‚úÖ Nenhuma competi√ß√£o semanal existente encontrada');
        return false;
      }

      // Verificar sobreposi√ß√£o usando compara√ß√£o de strings simples
      for (const competition of existingWeeklyCompetitions) {
        const existingStart = competition.start_date.split('T')[0]; // Apenas data YYYY-MM-DD
        const existingEnd = competition.end_date.split('T')[0];     // Apenas data YYYY-MM-DD
        const newStart = startDate.split('T')[0];                  // Apenas data YYYY-MM-DD
        const newEnd = endDate.split('T')[0];                      // Apenas data YYYY-MM-DD

        // Verificar se h√° sobreposi√ß√£o usando strings simples
        const hasOverlap = newStart <= existingEnd && newEnd >= existingStart;

        if (hasOverlap) {
          console.log('‚ùå Sobreposi√ß√£o detectada entre competi√ß√µes semanais (STRINGS):', {
            existingTitle: competition.title,
            existingPeriod: `${existingStart} - ${existingEnd}`,
            newPeriod: `${newStart} - ${newEnd}`
          });
          return true;
        }
      }

      console.log('‚úÖ Nenhuma sobreposi√ß√£o detectada entre competi√ß√µes semanais');
      return false;
    } catch (error) {
      console.error('‚ùå Erro ao verificar sobreposi√ß√£o:', error);
      throw error;
    }
  }

  async createCompetition(data: CompetitionFormData | CustomCompetitionData): Promise<ApiResponse<any>> {
    try {
      console.log('üéØ CORRE√á√ÉO RADICAL FINAL - Criando competi√ß√£o com STRINGS PURAS (ZERO convers√µes):', data);
      
      const { data: user } = await supabase.auth.getUser();
      if (!user.user) {
        throw new Error('Usu√°rio n√£o autenticado');
      }

      let competitionData: any;
      
      if ('type' in data) {
        // CORRE√á√ÉO RADICAL: Usar datas como STRINGS DIRETAS - ZERO convers√µes
        
        if (data.type === 'daily') {
          console.log('üîß RADICAL: Competi√ß√£o di√°ria - STRINGS PURAS (zero convers√µes)');
          
          // RADICAL: Se n√£o tem startDate, usar hoje como string simples
          const startDateString = data.startDate || new Date().toISOString().split('T')[0];
          
          competitionData = {
            title: data.title,
            description: data.description,
            competition_type: 'challenge',
            start_date: startDateString, // STRING PURA - trigger do banco far√° padroniza√ß√£o
            end_date: startDateString,   // STRING PURA - mesmo dia, trigger far√° 23:59:59  
            max_participants: data.maxParticipants,
            prize_pool: data.prizePool,
            theme: data.category || 'Geral',
            created_by: user.user.id,
            status: 'active'
          };
          
          console.log('‚úÖ RADICAL: Competi√ß√£o di√°ria - STRINGS PURAS enviadas:', competitionData);
        } else {
          console.log('üîß RADICAL: Competi√ß√£o semanal - verificando sobreposi√ß√£o com STRINGS PURAS...');
          
          // RADICAL: Se n√£o tem datas, usar hoje como string simples
          const startDateString = data.startDate || new Date().toISOString().split('T')[0];
          const endDateString = data.endDate || new Date().toISOString().split('T')[0];
          
          const hasOverlap = await this.checkWeeklyCompetitionOverlap(startDateString, endDateString);

          if (hasOverlap) {
            throw new Error('As datas desta competi√ß√£o semanal se sobrep√µem a uma competi√ß√£o semanal j√° existente. Por favor, escolha um per√≠odo diferente.');
          }
          
          competitionData = {
            title: data.title,
            description: data.description,
            competition_type: 'tournament',
            start_date: startDateString, // STRING PURA - trigger do banco far√° padroniza√ß√£o
            end_date: endDateString,     // STRING PURA - trigger far√° 23:59:59
            prize_pool: data.prizePool,
            max_participants: data.maxParticipants,
            created_by: user.user.id,
            status: 'scheduled'
          };
          
          console.log('‚úÖ RADICAL: Competi√ß√£o semanal - STRINGS PURAS enviadas:', competitionData);
        }
      } else {
        // RADICAL: Para dados diretos do formul√°rio - STRINGS PURAS
        console.log('üîß RADICAL: Dados diretos - STRINGS PURAS (zero convers√µes)');
        
        if (data.competition_type === 'challenge') {
          competitionData = {
            title: data.title,
            description: data.description,
            competition_type: 'challenge',
            start_date: data.start_date, // STRING PURA - sem convers√µes
            end_date: data.start_date,   // MESMO DIA - STRING PURA
            max_participants: data.max_participants,
            prize_pool: data.prize_pool,
            theme: data.theme || 'Geral',
            rules: data.rules,
            created_by: user.user.id,
            status: data.status || 'active'
          };
          console.log('‚úÖ RADICAL: Challenge - STRINGS PURAS enviadas:', competitionData);
        } else {
          console.log('üîß RADICAL: Tournament - verificando sobreposi√ß√£o com STRINGS PURAS...');
          
          const hasOverlap = await this.checkWeeklyCompetitionOverlap(data.start_date, data.end_date);

          if (hasOverlap) {
            throw new Error('As datas desta competi√ß√£o semanal se sobrep√µem a uma competi√ß√£o semanal j√° existente. Por favor, escolha um per√≠odo diferente.');
          }
          
          competitionData = {
            title: data.title,
            description: data.description,
            competition_type: 'tournament',
            start_date: data.start_date, // STRING PURA - sem convers√µes
            end_date: data.end_date,     // STRING PURA - sem convers√µes
            prize_pool: data.prize_pool,
            max_participants: data.max_participants,
            rules: data.rules,
            created_by: user.user.id,
            status: data.status || 'scheduled'
          };
          
          console.log('‚úÖ RADICAL: Tournament - STRINGS PURAS enviadas:', competitionData);
        }
      }

      console.log('üöÄ RADICAL FINAL: Enviando STRINGS PURAS para o banco (ZERO convers√µes):', competitionData);

      const { data: competition, error } = await supabase
        .from('custom_competitions')
        .insert(competitionData)
        .select()
        .single();

      if (error) throw error;

      console.log('‚úÖ RADICAL APLICADO: Competi√ß√£o criada com STRINGS PURAS:', competition.id);
      console.log('üéØ VERIFICAR: Datas preservadas? Start:', competition.start_date, 'End:', competition.end_date);
      
      return createSuccessResponse(competition);
    } catch (error) {
      console.error('‚ùå RADICAL: Erro ao criar competi√ß√£o:', error);
      return createErrorResponse(handleServiceError(error, 'CREATE_COMPETITION'));
    }
  }

  async getCustomCompetitions(): Promise<ApiResponse<any[]>> {
    try {
      console.log('üìã Buscando competi√ß√µes customizadas...');
      
      const { data, error } = await supabase
        .from('custom_competitions')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) throw error;

      console.log('‚úÖ Competi√ß√µes carregadas:', data?.length || 0);
      return createSuccessResponse(data || []);
    } catch (error) {
      console.error('‚ùå Erro ao buscar competi√ß√µes:', error);
      return createErrorResponse(handleServiceError(error, 'GET_COMPETITIONS'));
    }
  }

  async getActiveCompetitions(): Promise<ApiResponse<any[]>> {
    try {
      console.log('üéØ Buscando competi√ß√µes ativas...');
      
      const { data, error } = await supabase
        .from('custom_competitions')
        .select('*')
        .eq('status', 'active')
        .order('start_date', { ascending: true });

      if (error) throw error;

      console.log('‚úÖ Competi√ß√µes ativas encontradas:', data?.length || 0);
      return createSuccessResponse(data || []);
    } catch (error) {
      console.error('‚ùå Erro ao buscar competi√ß√µes ativas:', error);
      return createErrorResponse(handleServiceError(error, 'GET_ACTIVE_COMPETITIONS'));
    }
  }
}

export const customCompetitionCoreService = new CustomCompetitionCoreService();
